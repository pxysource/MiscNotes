# 1. 伪指令

在 ARM 汇编语言中，**伪指令（pseudo-instruction）不是实际由 CPU 执行的机器指令，而是汇编器（如 GNU `as`、ARM 的 `armasm`）提供的一种辅助指令**，用于简化编程、增强可读性或生成某些数据和结构。

常用伪指令如下表所示：

| 伪指令               | 说明                                             |
| -------------------- | ------------------------------------------------ |
| `.global` / `.globl` | 声明全局符号，可被其他文件访问                   |
| `.extern`            | 声明外部符号                                     |
| `.section`           | 指定目标节（如 `.text`、`.data`）                |
| `.text`              | 指定代码节                                       |
| `.data`              | 指定数据节                                       |
| `.bss`               | 指定未初始化数据节                               |
| `.align`             | 对齐指令或数据                                   |
| `.word`              | 分配一个 32 位整数                               |
| `.short` / `.hword`  | 分配一个 16 位整数                               |
| `.byte`              | 分配一个 8 位整数                                |
| `.ascii`             | 输出字符串，不包括结尾的 null 字节               |
| `.asciz` / `.string` | 输出以 null 结尾的字符串                         |
| `.space` / `.skip`   | 分配指定字节的空间并填充（常用于 `.bss`）        |
| `.equ` / `.set`      | 定义常量符号，例如 `.equ SIZE, 0x100`            |
| `.ltorg`             | 在当前位置放置文字常量池（常用于 `ldr =symbol`） |

## 1.1. `.equ`

在 ARM 汇编中，`.equ` 是一个 **伪指令（pseudo-op）**，用于给一个符号赋常量值，即**定义一个常量**，和 C 语言中的 `#define` 类似。

### 1.1.1. 语法

```
.equ <symbol>, <constant-expression>
```

也可以写成 `.set`，两者是等价的：

```
.set <symbol>, <constant-expression>
```

### 1.1.2. 示例：定义常量与使用

```assembly
.equ LED_PORT, 0x40021018    // 定义常量 LED_PORT
.equ LED_ON,   1
.equ LED_OFF,  0

.section .text
.global _start

_start:
    ldr r0, =LED_PORT        // 使用常量地址
    mov r1, #LED_ON          // 常量值
    str r1, [r0]             // 开灯

    mov r1, #LED_OFF
    str r1, [r0]             // 关灯

    b .                      // 死循环
```

### 1.1.3. 特点

| 特性       | 说明                                                |
| ---------- | --------------------------------------------------- |
| 常量绑定   | `.equ` 声明的值是汇编时的常量，不能在运行时更改     |
| 全局有效   | 在声明之后，全文件都可以使用这个符号                |
| 表达式支持 | 可以是简单数字、符号间计算，如 `.equ SIZE, 512 * 4` |

### 1.1.4. 高级用法：表达式与计算

```assembly
.equ BASE, 0x1000
.equ OFFSET, 0x20
.equ FINAL_ADDR, BASE + OFFSET    // 结果是 0x1020

ldr r0, =FINAL_ADDR
```



## 1.2. `.word`

在 ARM 汇编中，`.word` 是一个伪指令（pseudo-instruction），用于**在当前地址写入一个或多个 32 位的常量值**。它不会生成 CPU 指令，而是在目标二进制中写入数据，常用于初始化变量、定义常量表或手动写入内存。

### 1.2.1. 语法

```
.word value1[, value2, value3, ...]
```

- 每个 `value` 是一个 **32 位无符号整数**、符号、表达式或地址。

- 支持写入多个值，用逗号分隔。

### 1.2.2. 示例：定义一个常量数据表

```assembly
.data
table:
    .word 0x12345678
    .word 0xDEADBEEF, 0xCAFEBABE, 42
```

上面代码会在 `table` 开始的位置顺序写入四个 32 位值。

### 1.2.3. 示例：与 `.text` 段结合使用

```assembly
.text
.global _start

_start:
    ldr r0, =my_data       // 加载数据地址
    ldr r1, [r0]           // 读取第一个 word 到 r1

    b .

.align 4
my_data:
    .word 0x11223344

```

### 1.2.4. 示例：符号作为值

```assembly
.equ BASE, 0x10000000
.data
    .word BASE + 0x20      // 写入地址 0x10000020

```

### 1.2.5. 常见用途

| 用途          | 示例                          |
| ------------- | ----------------------------- |
| 初始化数据    | `.word 0x12345678`            |
| 常量表        | 查表加速计算，如正弦表等      |
| 地址引用      | `.word func_addr`，用于跳转表 |
| 与 C 联合使用 | 在裸机程序中定义变量初值      |

### 1.2.6. 补充相关指令

| 指令                | 含义                                 |
| ------------------- | ------------------------------------ |
| `.byte`             | 写入 1 字节（8 位）                  |
| `.hword` / `.short` | 写入 2 字节（16 位）                 |
| `.word`             | 写入 4 字节（32 位）                 |
| `.dword`            | 写入 8 字节（64 位，某些汇编器支持） |

## 1.3. `.align`

在 ARM 汇编中，`.align` 是一个 **伪指令**，用于**对齐当前位置**，使接下来的指令或数据**从指定的地址边界开始**。

### 1.3.1. 语法

```
.align n

```

其含义为：**将当前位置向上对齐到 2ⁿ 字节边界**。

### 1.3.2. 示例含义

| `.align n` | 对齐到的边界           |
| ---------- | ---------------------- |
| `.align 0` | 1 字节对齐（即不对齐） |
| `.align 1` | 2 字节对齐             |
| `.align 2` | 4 字节对齐             |
| `.align 3` | 8 字节对齐             |
| `.align 4` | 16 字节对齐            |
| ...        | 依此类推               |

### 1.3.3. 常见用途

#### 1.3.3.1. 对齐变量地址

```assembly
.data
.align 2         // 4 字节对齐
my_data:
    .word 0x12345678

```

这样 `my_data` 的地址会从 4 字节边界开始，有利于 ARM CPU 正常访问。

#### 1.3.3.2. 对齐指令地址（代码段）

```assembly
.text
.global _start
_start:
    mov r0, #0

.align 4        // 16 字节对齐，可提高性能或满足平台要求
my_func:
    bx lr

```

某些启动代码（如中断向量表）强制要求对齐，例如 32 字节。

#### 1.3.3.3. 指定跳转表或数据表起始地址

```assembly
.align 3       // 8 字节对齐
jump_table:
    .word handler1
    .word handler2

```

有利于表索引计算和 CPU 的字对齐加载。

### 1.3.4. 注意：GNU 与 ARM 汇编器区别

| 汇编器     | `.align n` 的含义 |
| ---------- | ----------------- |
| GNU (`as`) | 对齐到 2ⁿ 字节    |
| ARMASM     | 对齐到 `n` 字节   |

👉 所以：

```assembly
.align 2

```

- 在 GNU 汇编器中：表示 **4 字节对齐**
- 在 ARMASM 中：表示 **2 字节对齐**

⚠️ **两者语义不同，注意平台差异！**

## 1.4. `.text`

在 ARM 汇编中，`.text` 是一个 **伪指令（pseudo-instruction）**，用于告诉汇编器：

> **从此处开始的是程序代码（可执行指令段）**，也就是**代码段（text section）**。

### 1.4.1. 基本作用

- `.text` 表示**代码段的开始**。
- 编译后，这部分内容将被放入可执行文件的 `.text` 节中（只读、可执行）。
- 通常用于放置程序入口、函数、跳转逻辑等机器指令。

### 1.4.2 使用方式

```assembly
.text
.global _start      @ 声明入口点
_start:
    mov r0, #0
    b .

```

- `.text` 表示接下来是代码。

- `_start:` 是全局入口，常用于裸机或 Linux 程序起点。

- 可以和 `.data` / `.bss` 搭配使用，分别定义数据段和未初始化段。

### 1.4.3. 扩展形式

也可以使用 `.section` 显式指定：

```assembly
.section .text

```

效果等同于 `.text`，但 `.section` 更通用（可用来自定义任意段）。

### 1.4.4. 示例：含 `.text` 的简单程序

```assembly
.text
.global _start

_start:
    mov r0, #1       @ 假设表示成功
    mov r7, #1       @ SYS_exit
    svc 0

```

这个例子是 Linux 下最小的退出程序，`.text` 指定代码段开始。

### 1.4.5. 与 `.data`、`.bss` 的区别

| 指令    | 含义           | 内容类型             |
| ------- | -------------- | -------------------- |
| `.text` | 代码段         | 指令（machine code） |
| `.data` | 数据段         | 已初始化变量         |
| `.bss`  | 未初始化数据段 | 零初始化变量         |

## 1.5. `.global`

在 ARM 汇编中，`.global`（或 `.globl`）是 **GNU 汇编器（GAS）** 支持的伪指令，用于**声明一个全局符号**，使该符号可以被链接器识别并供其它模块使用。

### 1.5.1. 作用

> 将某个符号（函数名、变量名）标记为**全局可见**，可以被外部引用。

就像 C 中的 `extern` 与 `global symbol` 的概念类似。

### 1.5.2. 语法

```assembly
.global <symbol_name>

```

也可以写作 `.globl`（拼写差异，两者完全等价）。

### 1.5.3. 示例：程序入口声明（裸机或Linux）

```assembly
.text
.global _start     @ 声明 _start 是全局符号，作为入口
_start:
    mov r0, #0
    b .

```

- `_start` 通常是 ELF 可执行文件的默认入口点。

- 若不加 `.global`，链接器找不到符号 `_start` 会报错。

### 1.5.4. 示例：函数声明供 C 调用

```assembly
.text
.global my_func

my_func:
    mov r0, #42
    bx lr

```

- C 语言中可以这样调用：

```c
extern int my_func(void);

```

链接器会找到汇编中的 `my_func`。

### 1.5.5. 示例：配合 `.data` 导出变量

```assembly
.data
.global counter
counter:
    .word 0

```

- 这个变量 `counter` 现在是一个全局变量，可以被其他 C 文件中的 `extern int counter;` 使用。

## 1.6. AMR 伪指令：`ADR`

**小范围的地址读取伪指令**。

ADR 指令将基于 PC 相对偏移的地址值读取到寄存器中。

在汇编编译源程序时，ADR 伪指令被编译器替换成一条合适的指令。通常，编译器用一条 ADD 指令或 SUB 指令来实现该 ADR 伪指令的功能，若不能用一条指令实现，则产生错误,编译失败。

### 1.6.1. 语法

```
ADR{cond} register,exper
```

- register：加载的目标寄存器。
- exper：地址表达式。当地址值是非字对齐时，取值范围 `-255~255` 字节之间；当地址是字对齐时，取值范围 `-1020~1020` 字节之间。对于基于 PC 相对偏移的地址值时，给定范围是相对当前指令地址后两个字处(因为 ARM7TDMI 为三级流水线)。

### 1.6.2. 示例

```assembly
loop:
	mov r1, #0xF0
	...
	adr r2, loop
	adr r3, loop + 4
```

## 1.7. ARM 伪指令：`ADRL`

**中等范围的地址读取伪指令**。

ADRL 指令将基于 PC 相对偏移的地址值或基于寄存器相对偏移的地址值读取到寄存器中，比 ADR 伪指令可以读取更大范围的地址。

在汇编编译源程序时，ADRL 伪指令被编译器替换成两个条合适的指令。若不能用两条指令实现 ADRL 伪指令功能，则产生错误，编译失败。

### 1.7.1. 语法

```
ADR{cond} register, exper
```

- register：加载的目标寄存器
- expr：地址表达式。当地址值是非字对齐时，取范围 `-64K~64K` 字节之间；当地址值是字对齐时，取值范围 `-256K~256K` 字节之间。

### 1.7.2. 示例

ARM 风格汇编。

```assembly
ADRL R0,DATA_BUF 
… 
ADRL R1 DATA_BUF+80 
… 
DATA_BUF 
SPACE 100 ;定义 100 字节缓冲区
```

# 2. 数据处理指令

## 2.1. 数据传送指令

### 2.1.1. `mov`

数据传送指令。将**8位图立即数**或**寄存器 ** (operand2) 传送到目标寄存器 `Rd`，可用于移位运算等操作。

#### 2.1.1.1. 语法

```
MOV{cond}{S} Rd,operand2

```

- `Rd`：目标寄存器
- `Operand2`：立即数或另一个寄存器（或带移位的寄存器）

#### 2.1.1.2. 示例：常见用法

```assembly
MOV r0, #5       @ 把立即数 5 赋值给 R0
MOV r1, #0xFF    @ 十六进制数
mov r0, r1       @ 把 r1 的值复制到 r0
```

#### 2.1.1.3. ⚠️ 立即数限制

在 ARM 模式中：

```assembly
mov r0, #0x12345678   @ ❌ 报错！立即数超出范围

```

因为 ARM 的 `mov` 指令不能加载任意 32 位常数。

推荐做法：

```assembly
ldr r0, =0x12345678   @ ✅ 使用伪指令，汇编器会生成 .word 常量池

```

或者使用 `movw`/`movt`（仅限支持的架构）：

```assembly
movw r0, #:lower16:0x12345678
movt r0, #:upper16:0x12345678

```

# 3. 存储访问指令

ARM 处理器是**加载/存储**体系结构的典型的 RISC 处理器，对存储器的访问只能使用加载和存储指令实现。

ARM 的加载/存储指令是可以实现字、半字、无符/有符字节操作；批量加载/存储指令可实现一条指令加载/存储多个寄存器的内容，大大提高效率；`SWP` 指令是一条寄存器和存储器内容交换的指令，可用于信号量操作等。

ARM 处理器是**冯.诺依曼存储结构**，程序空间、RAM 空间及 IO 映射空间统一编址，除对 RAM 操作以外，对外围 IO、程序数据的访问均要通过加载/存储指令进行。

## 3.1. `ldr`

加载字和无符号字节指令。

`LDR` 指令用于从内存中读取数据放入寄存器中。

### 3.1.1. 语法

```
LDR{cond}{T} Rd,<地址>
```

加载指定地址上的数据(字)，放入 Rd 中。

## 3.1. `str`

存储字和无符号字节指令。

STR 指令用于将寄存器中的数据保存到内存。

### 3.1.1. 语法

```
STR{cond}{T} Rd,<地址>
```

存储数据(字)到指定地址的存储单元，要存储的数据在 Rd 中。

# 4. 跳转指令

在 ARM 中有两种方式可以实现程序的跳转，一种是使用**跳转指令**直接跳转，另一种则是**直接向 `PC` 寄存器赋值**实现跳转。

跳转指令：

- 跳转指令 `B`
- 带链接的跳转指令 `BL`
- 带状态切换的跳转指令 `BX`

## 4.1. `B`

跳转到指定的地址执行程序。

> [!important]
>
> 限制在当前指令的**±32Mb** 的范围内。

### 4.1.1. 语法

```
B{cond} label
```

### 4.1.2. 示例

跳转到 `WAITA` 标号处。

```assembly
B WAITA
```

跳转到绝对地址 `0x1234` 处。

```assembly
B 0x1234
```

## 4.2. `BL`

带链接的跳转指令。将下一条指令的地址拷贝到 R14(LR) 链接寄存器中，然后跳转到指定地址运行程序。

> [!important]
>
> 1. 限制在当前指令的**±32Mb** 的范围内。
> 2. `BL` 指令用于子程序调用。

### 4.2.1. 语法

```
BL{cond} label
```

### 4.2.2. 示例

```assembly
BL DELAY
```

# 5. 数据处理指令

## 5.1. 比较指令

### 5.1.1 `CMP`

指令使用寄存器 Rn 的值减去 operand2 的值，根据操作的结果设置 CPSR 中的相应条件标志位，以便后面的指令根据相应的条件标志来判断是否执行。

#### 5.1.1.1. 语法

```
CMP{cond} Rn,operand2
```

#### 5.1.1.2. 示例

R1 与 10 比较，设置相关标志位。

```assembly
cmp r1, #10
```

r1 与 r2 比较，设置相关标志位。

```assembly
CMP r1,r2
```

# 汇编预定义变量及伪指令

## 预定义的寄存器和协处理器名

ARM 汇编器对 ARM 的寄存器进行了预定义(包括 APCS 对 R0~R15 寄存器的定义)，所有的寄存器和协处理器名都是大小写敏感。

### 通用寄存器

| 名称             | 描述                             |
| ---------------- | -------------------------------- |
| R0~R15 和 r0~r15 | 16个通用寄存器                   |
| a1~a4            | 参数、结果或临时寄存器，同 R0~R3 |
| v1~v8            | 变量寄存器，同 R4~R11            |
| SB 和 sb         | 静态基址，同 R9                  |
| SL 和 sl         | 堆栈限制，同 R10                 |
| FP 和 fp         | 帧指针                           |
| IP 和 ip         | 过程调用中间临时寄存器，同 R12   |
| SP 和 sp         | 堆栈指针，同 R13                 |
| LR 和 lr         | 链接寄存器，同 R14               |
| PC 和 pc         | 程序计数器，同 R15               |

### 程序和状态寄存器

CPSR 和 cpsr。

SPSR 和 spsr。

# 参考

1. 《ARM指令速查手册.pdf》
